# 네트워크 선 자르기(ton-down) - 동적계획법 with dfs

## 문제 
현수는 네트워크 선을 1m, 2m의 길이를 갖는 선으로 자르려고 합니다. 예를 들어 4m의 네트워크 선이 주어진다면
1) 1m+1m+1m+1m 
2) 2m+1m+1m  
3) 1m+2m+1m  
4) 1m+1m+2m  
5) 2m+2m  

5가지 방법을 생각할 수 있습니다. 

(2)와 (3)과 (4)의 경우 왼쪽을 기준으로 자르는 위치가 다르면 다른 경우로 생각한다.
그렇다면 네트워크 선의 길이가 Nm라면 몇 가지의 자르는 방법을 생각할 수 있나요?


## 알고리즘
네트워크 선을 1,2의 길이로 선을 자르려고 하는것은 1,2일때 각각의 경우일때 서로 혼합되어질수있다. 
1과2를 가지고 경우의수를 구해도 된다. 하지만 매 반복수에서 경우의 수를 구하려고 하면 이중포문으로 돌아야 하고 
시간복잡도는 n^2이 될것이다. 
이를 빠르게 해결할수있는 방법은 다이나믹프로그래밍이다. 

다이나믹 프로그래밍은 점화식을 통해서 규칙을 찾는 프로그래밍이다. 
점화식을 통해서 규칙을 찾았다면 이를 메모이제이션 기법을 통해서 효율적으로 공간을 사용하여 
메모리를 절약할수있다.

1,2의 길이로 잘라야하는것은 n이 1~n 까지일때 n을 1,2로 짤라야하는경우의 수이다. 

1일때는 1가지  
2일때는 2가지  
3일때는 3가지   
4일때는 5가지   
늘어나고 이를 통해서 점화식을 계산하면
f(x) = f(x-2) + f(x-1) 이라는 점화식을 가져올수있다. 

이런 점화식에서 재귀를 이용하여 위에서부터 아래로 내려가는 재귀는 top-down방식이라고 한다. 


```
#include <stdio.h>
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

int dy[101];

int dfs(int x){

    if(dy[x] > 0) return dy[x];
    if(x == 1) return dy[1] = 1;
    if(x == 2) return dy[2] = 2;

    return dy[x] = dfs(x-1) + dfs(x-2);
}

int main(){
    ios_base::sync_with_stdio(false);
    int n;
    cin >> n;

    cout << dfs(n)<<"\n";

}

```
