## 영지의갯수(large)

* 문제 
세종대왕은 현수에게 현수가 다스릴 수 있는 영지를 하사하기로 했다. 전체 땅은 사각형으로 표 시된다. 그 사각형의 땅 중에서 세종대왕이 현수가 다스릴 수 있는 땅의 크기(세로의 길이와 가 로의 길이)를 정해주면 전체 땅 중에서 그 크기의 땅의 위치를 현수가 정하면 되는 것이다. 전체 땅은 사각형의 모양의 격자로 되어 있으며, 그 사각형 땅 안에는 많은 오렌지 나무가 심 겨져 있다. 현수는 오렌지를 무척 좋아하여 오렌지 나무가 가장 많이 포함되는 지역을 선택하 고 싶어 한다. 현수가 얻을 수 있는 영지의 오렌지 나무 최대 개수를 출력하는 프로그램을 작 성하세요. 다음과 같은 땅의 정보가 주어지고, 현수가 하사받을 크기가, 가로 2, 세로 3의 크 기이면 가장 많은 오렌지 나무가 있는 영지는 총 오렌지 나무의 개수가 16인 3행 4열부터 시 작하는 구역이다.

6 7
3 5 1 3 1 3 2 
1 2 1 3 1 1 2 
1 3 1 5 1 3 4 
5 1 1 3 1 3 2 
3 1 1 3 1 1 2 
1 3 1 3 1 2 2 
2 3

* 알고리즘

dp를 이용한 방법으로 풀었다. 
i,j를 기준으로 (i,j-1) (i-1,j)를 더하고 중복된 (i-1,j-1)를 빼주며 a[i][j]를 더해주므로 i,j에 해당하는 크기의 값의 합을 구할수 있었다. 

우리는 현수의 크기 2,3의 최대값을 구해야하므로 
구해진 dp배열에서 현수의 크기 2,3에 해당하는 -(i,j-3) -(i-2,j) +(i-2,j-3)을 해주면 크기만큼의 값을 구할수가 있었다. 이렇식으로 O(N^2)으로 계산할수있다. 

나는 슬라이딩 윈도우 방법을 통해서도 가능할거같다.
나중에 도전하자.

```
#include<cstring>
#include<vector>
#include<algorithm>
using namespace std;
int a[701][701], dy[701][701];
int main(){
    int h ,w ,n ,m ,i ,j ,tmp ,max = -2147000000;

    scanf("%d %d", &h,&w);
    for(i = 1; i<=h;i++){
        for(j = 1; j<=w; j++){
            scanf("%d",&a[i][j]);
            dy[i][j] = dy[i-1][j] + dy[i][j-1] -dy[i-1][j-1] + a[i][j];
        }
    }
    scanf("%d %d",&n,&m);
    
    for(i = n; i<=h; i++){
        for( j = m ; j<=w; j++){
            tmp = dy[i][j] - dy[i][j-m] - dy[i-n][j] +dy[i-n][j-m];
            if(tmp>max) max = tmp;
        }
    }
    printf("%d\n",max);
    return 0;
}
```