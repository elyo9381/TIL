# 줄서기 플랫폼

### 행사 도메인 CRUD 기능

1. 행사는 고객사만 생성가능하다.

아래 키워드는 필수 파라미터 

```
1.  행사 이름 (option)
2.  행사 설명 (option)
3.  행사 장소 (option)
4.  행사 시간 (from ~ to) (option)
5.  인원 (option)
6.  대기열 운영 시간 (필수)
7.  종류 (option)
8.  작업열 크기 (필수)
9.  작업열 접근 시간 (필수)
10.  redirectUrl (option)
```

```
행사 도메인
1. 행사 Sequence
2. 행사 식별자 (`UUID`, Base31 Encoding)
3. 행사 이름 (option)
4. 행사 설명 (option)
5. 행사 장소 (option)
6. 행사 인원 (option)
7. 행사 시간 (option)
8. 대기열 운영 기간 → 행사 기간이 10일이면 3일만 대기열을 쓰고 싶다.
9. 대기열 운영 시간 → am 10시부터  pm 1시까지만 사용하겠다.
10. 종류(공연, 숙박, 엑티비티… ) - 통계 용도
11. 대기열 크기
12. 작업열 크기
13. 등록 시간
14. 수정 시간
15. 작업열 접근 시간 → cache eviction
16. 전체 대기열 접근 인원
17. RedirectUrl(DeepLink) - option ⇒ 대기열 페이지를 우리가 만들면 받아야 할것 같다.
```

--- 

### 고객사 도메인 CRUD 기능

- crud가 API 필요할까요 ?
- 직접 디비에 넣는다. or API를 만든다. 혹시 모르니
- 추후에 관리자 페이지가 생성되면 필요

--- 

### 토큰 발급 기능

1. 사용자는 고객사 서버에 인증을 요청한다.
2. 고객사는 대기열의 서버에 인증을 요청하며, 대기열은 JWT 토큰을 발급한다.
3. 고객사는 발급 받은 JWT 토큰을 사용자에게 전달한다.

#### Request

```
Authorization : "ClientId:(StringToSign를 ClientSecret으로 Hmac 암호화)"

{
	"userId" : "", // 유저 식별자
	"eventId" : "" // 이벤트 식별자
}
```

#### Response

```
{
    "accessToken" : JWT 토큰
}
```

---

### 사용자 대기열 진입 기능

1. 토큰이 대기열에서 발급한것인지 검증
2. 행사에 맞는 대기열인지 검증
3. 대기열 진입여부 정보 응답

#### Request

```
clientId : String // 고객사 식별자
Authorization : AccessToken // 대기열 진입 토큰

{
	"eventId" : String // 이벤트 식별자
}
```

#### Response

```
{
	"status" : Enum( WAIT , ENTER ), // 고객의 현재 상태
	"expectedInfo" : {  // 대기 정보
			"time" : ISO-8601(hh:mm:ss+09:00), // 남은 시간(기준 시간 명시)
			"order" : Int      // 대기 순번
	}
}
```

--- 

### 사용자 대기열 조회 기능

- 특정시간 마다 API 호출하여 현재 고객의 순번을 확인한다.
- 고객이 작업열에 들어 갈 수 있는지 판단한다.
    - 작업열에 들어 갈 수 있으면 status : ENTER
    - 작업열에 들어 갈 수 있으면 status : WAIT
- 대기열 만료 시간을 업데이트 한다.
    - 시간은 폴링 시간에 비례해서 정한다.

#### Request

```
clientId : String // 고객사 식별자
Authorization : AccessToken // 대기열 진입 토큰

{
	"eventId" : String // 이벤트 식별자
}
```

#### Response

```
{
	"status" : Enum( WAIT , ENTER ), // 사용자의 현재 상태
	"expectedInfo" : {  // 대기 정보
			"time" : ISO-8601(hh:mm:ss+09:00), // 남은 시간(기준 시간 명시)
			"order" : Int      // 대기 순번
	}
}
```
--- 

### 사용자 작업열 검증 기능

- server side
- 고객사 서버에서 작업을 시작 전 호출한다.
- 해당 사용자가 작업열에 있는지를 검증한다.

#### Request

```
Authorization : "ClientId:(StringToSign를 ClientSecret으로 Hmac 암호화)"

{
    "userId" : String, // 사용자 식별자
    "eventId" : String // 이벤트 식별자
}
```

#### Response

- HTTP Status 로 표시

> 200 : 작업열에 사용자가 있을 때 <br/>
> 401 : 인증이 실패했을 때 <br/>
> 403 : 작업열에 사용자가 없을 때 <br/>

--- 

### 사용자 작업 종료 기능

- server side
- 작업이 완료된 후 호출한다.
- 작업열에서 해당 사용자를 제거한다.

#### Request

```
Authorization : "ClientId:(StringToSign를 ClientSecret으로 Hmac 암호화)"

{
    "userId" : String, // 사용자 식별자
    "eventId" : String // 이벤트 식별자
}
```

#### Response

- HTTP Status 로 표시

> 200 : 작업열에서 사용자 제거 성공 <br/>
> 401 : 인증이 실패했을 때 <br/>
> 403 : 작업열에 사용자가 없을 때 <br/>

--- 

### 사용자 대기열 -> 작업열 이동 기능

- scheduler
- 작업열의 수가 일정 이하 떨어지면 대기열의 사용자를 작업열로 이동

--- 

### 사용자 대기열 및 작업열 만료시간 체크 기능

- cache eviction
- 대기열/작업열의 사용자 만료 시간을 확인하여 고객을 대기열/작업열에서 제거한다.
- 대기열/작업열의 만료 시간을 다르게 둔다.(ex) 대기열 1분, 작업열 5분)

--- 

## 비실물 이커머스






# 자바

- 자바의 기본 변수 4종류가 있는데 이는 무엇인가?
	- 지역변수 : 중괄호에 안에 존재하는 지역적인 변수들
	- 매개변수 : 함수의 매개로 넘어온 변수들
	- 인스턴스변수 : 클래스 생성시에 정의되거나 선언된 변수
	- 클래스변수 : 클래스와 동일하게 생성되고 , 소멸되는 변수 static 이 붙는변수
		- 클래스 생성시에 JVM 메소드영역에 클래스의 정보가 등록된다. 
		- 또한 static이 붙으면 전역변수인데 이또한 JVM 메소드영역에 해당 메모리의 정보가 등록되기 때문이다.
- 자바에서 기본타입과 참조 타입의 무엇이며 차이는 무엇인가. ? 
	- 기본형은 int, long, double, char 등등의 변수입니다.
	- 기본형의 특징으로는 초기화하지 않으면 컴파일에러가 뜹니다. 
	- 참조형은 object를 상속한 클래스라고 말씀드리고 싶습니다. 
	- 참조형은 GC의 대상이 됩니다. 
	- 참조형은 JVM 메모리의  힙영역에 인스턴스 변수가 등록된다. 왜냐? -> 클래스를 가지고 만들 변수들이기 때문이다. 
- JVM 메모리 
	- 스택 : 지역 변수, 매개변수가 해당 
	- pc :  스택영역의 count를 알고있는 곳이다. 
	- native ~~ : c, c++로 구성된 파일을 실행하는곳이다. (자바에서 성능향상을위해서 사용)
	- 힙 : new 키워드로 생성된 데이터들이 점유하는 메모리 영역이다. 
	- 메소드 영역 : 최초 클래스 정보 및 static 정보가 점유하는 메모리 영역이다. 
	- 힙과 메소드 영역은 공유되는 영역이다.
- 그렇다면 interface는 JVM에서 어떤 영역에 올라가는가 ? 
	- 음.. 내생각으로는 메소드영역에 interface(클래스) 정보가 등록되고, 이를 오버라이딩 하는곳에서 지역변수처럼 스택에 올라갈것 같다. -> 결국 정의만 해놓은것이지, 함수를 구현한것은 구현체 이므로 
- 람다는 어떻게 JVM 메모리 영역에 올라가나 
	- 람다는 익명객체 (익명함수이다.) 힙에올라가고 , 익명객체를 받는 함수쪽에서 function interface로 되어있다면 매개변수로 받게 된다.  매개변수로 받게된 익명객체의 변수는 , 스택에서 직접 계산이 되고 이를 통해서 수행이 완료되면 스택에서 사용된 변수는 메모리 해제, 그리고 람다로 생성된 인스턴스 변수 ( 매개변수로 넘긴) 파라미터 또한 참조하는 곳이 없으니 GC대상, 익명객체(람다도) 더이상 참조되는 곳이 없으니 GC의 대상이 될것으로 생각된다.