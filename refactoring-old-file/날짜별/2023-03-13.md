# 이력서 재수정


#  프로젝트 개요 잡기 

## 내가 생각한 주요 피처들
- 예약(주문) 도메인,
	- 수량 
	- 예약 , 일괄 예약 
	- 좌석이 존재한다면 다중 좌석 예약
- 유저 도메인,
	- 권한 별 기능 
		- 관리자 , 유저
	- 회원(crud)
		- 회원 가입, 수정 , 삭제 
	- 회원 권한 
	- authentication  처리 ->  세선, JWT ?
	- 이력 및 푸시 
		- 회원 가입 및 정보 변경시 

		1. 회원가입 기능
		2. 회원 유효성 검증 기능
		3. 회원 정보 수정 기능 
		4. 회원 탈퇴 기능 
		5. 회원 권한 기능 
		6. 판매자
		7. 구매자


- 상품 도메인, ( 예를 들어 쿠팡 같은 여러 판매자가 존재 ? )
	- 판매자가 다를경우 
	- 상품이 다를경우 티켓 
	- 권한에 따라 상품 등록이 가능해야함 
		
	1. 상품 등록
	2. 상품 유효성 검증
	3. 상품 수정 
	4. 상품 제거 

- 조회 
	- 남은 수량만큼만 제공 
	1. 남은 수량 조회

- 장바구니 ( 티켓만인가 , 혹은 다른것들이 들어올 가능성을 배제 할수없나 . ? )
- 할인 ? 

- 줄서기와 독립적인 예약 관리



## 프로젝트 고려시 주요 키워드
- TPS / RPS
- 1만  TPS
- 동기식 웹 앱의 경우, Tomcat thread count?
- TPS = 1000 / (latency ms / thread
- jmeter, ngrinder
	- vUser
 > [! 목표 ]
 > - 1만 TPS를 달성한다.  
 >   달성 과정에서 사용한 기술을 이해하고, 블로킹 포인트, SPOF를 식별한다.  
 >   확장 가능한 포인트를 식별한다.  
 >   성능 테스트 도구의 개념(vUser 등) 을 이해하고 스크립팅할 수 있다.

- 행사 정보의 형태?
	- 행사의 정보가 어떤 정보여야 최소화된 latency 를 갖게 될까?
-  도메인 추출  
- 행사의 카테고리와 무관하게 정보를 관리할 수 있도록, 유연성 있는 설계  
- 검색/조회성능은 좋아야 한다
- 클라이언트 -> 서버 요청이 아닌,  
- 서버 -> 클라이언트를 할 수 있는 기술
- 예상 시간 산식  
- 정확도를 높이려면? CTA -> Call to action  
- click logging  
- FE -> async call 비동기 API 호출  
- BE -> latency 굉장히 낮아야 함
- DB sharding
- shard key algorithm


## 줄서기 
- 관리자 
	- 입장 제한 
	- 동시 접속 가능 인원 제한 
	- 현재 대기 인원 수 및  남은 시간 제공
	- 이력





# 알고리즘

## 백트래킹에 대한 고찰

DFS시 중요개념

함수 호출 순서 
f(0) -> f(1) -> f(2)  

실질적인 실행순서 
f(2)  -> f(1) - > f(0)


> [! 어떨때 백트레킹을 써야할까]
> 모든 경우의 수를 확인할때, 백트레킹을 써야할것으로 보인다. 
> ex )
> 1. A -> Z 까지의 경로중에서 길이가 k 일때 
> 2. A 리스트의 모든 경우의 수를 B리스트에 맞춰야 할때 최대 , 최소를 계산할때



``` c++
int go(int here){

	if(here == n) return 0;
	
	int ret = 0;
	
	for(int i =0 ; i<4; i++){
		int temp_idx = mal[i];
		int mal_idx = move(temp_idx, a[here]);
		if(isMal(mal_idx, i )) continue;
		mal[i] = mal_idx;
		ret = max(ret, go(here + 1) + v[mal_idx]);
		mal[i] = temp_idx;
	}
	
	return ret;
}
```

위의 코드는 백트레킹이 일어나는 주요 코드인데 
어떤 아이템 4개가 존재할때 
아이템이 각각 특정 위치에 존재 할수 있는지 
아이템의 중복해서 위치에 존재하는지 확인 하며
각 아이템별 모든 경우의수를 계산하는 함수이다. 


