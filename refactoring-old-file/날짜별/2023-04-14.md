{
    "ServiceId": 1016,
    "GateId": 180,
    "Action": "IN",
    "TokenNo": 78720,
    "ResultCode": 0,
    "ResultMessage": "OK",
    "GateOperationMode": "GATE",
    "GateOperationNextUrl": "",
    "GateOperationMessageTitle": "",
    "GateOperationMessageDetail": "",
    "TokenState": "WAIT",
    "WaitNo": 5,
    "TotalWaitCount": 5,
    "UserElapseWaitTime": "00:00:00",
    "UserElapseWaitSeconds": 0,
    "UserElapseWaitPercent": 0,
    "UserExpectWaitTime": "00:00:00",
    "UserExpectWaitSeconds": 0,
    "GateExpectWaitTime": "00:00:01",
    "GateExpectWaitSeconds": 1
}

## CS
**spring에서 데이터베이스 커넥션 관리, 트랜잭션관리**
1. 커넥션
- 커넥션이란 무엇일까요?
	tcp,udp를 네트워크 통신을 하기위해서 미리 만들어 놓은 규칙입니다.
	대체적으로 TCP를 사용하죠
- 왜쓰는가? TCP를 사용한다고 앞에서 말씀드렸는데 TCP 통신은  3 way handSahke가 필요합니다. 
   이는 서버와 다른서버(클라이언트 ex-DB)가 통신함에 있어서 계속 3 way handSahke을 진행해야하며, 이를  수행하는것은 매우 자원을 낭비하는 일입니다. 
   서버와 다른서버(클라이언트 ex-DB)의 통신에 있어, 즉 제한적인 통신이라고 가정할때, 3 way handSahke 미리 만들어 놓고 사용하면 우리는 더 효율적입니다. ( 레이턴시, 스르풋 등등) 
   그러므로 우리는 이를 위해서 TCP Connection이란것을 만들어 사용하고,  대표적인 예로 spring rdb의 hikari pool, spring redis의 jedis connection pool, spring redis의 lettuce connection pool 이 존재합니다.
   > 서버와 다른서버(클라이언트 ex-DB) 와 통신시에 대부분 이러한 connection pool을 사용하게 될겁니다.

2. 트랜잭션관리
- 트랜잭션이란 DB상에서 여러 커넥션에서 진행된 일들을 DB의 동일 한 범위안에서 처리를 보장하는 규칙이라고 말씀드리고 싶습니다.
- 트랜잭션과 관련이 깊은것이 ACID입니다.
1. 원자성
2. 일관성
3. 격리성
4. 지속성

> 격리성에 따른  4가지 격리성 수준
> 1. serializable
>   트랜잭션을 순차적으로 진행 시키는 것을 의미합니다. 
>   여러 트랜잭션이 동시에 같은 행에 접근 할 수 없습니다.
> 2. repeatable read
>   하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정 할 수 없도록 막아줍니다.
>   하지만 새로운 행을 추가하는 것은 막지 않습니다.
> 3. read commited
>   커밋 완료된 데이터에 대해서만 조회를 허용합니다.
>   하지만 어떤 트랜잭션이 접근 한 행을 다른 트랜잭션이 수정 할 수 있습니다.
>   그렇기 때문에 트랜잭션 A가 같은 행을 다시 읽을 때 다른 내용이 발견 될 수 있습니다
> 4.read uncommited
>   트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠릅니다.
> 

> 격리 수준에 따라 발생하는 현상
> - phantom read
> 트랜잭션 내에서 동일한 쿼리를 보냈을 때, 해당 조회 결과가 다른 경우를 말합니다.
> - non repeatable read
> 트랜잭션 내의 같은 행에 두번 이상 조회가 발생했는데, 그 값이 다른 경우를 가리킵니다.
> - dirty read
> 트랜잭션이 실행 중일 때, 다른 트랜잭션에 의해 수정되었지만, 아직 '커밋되지 않는' 행의 데이터를 읽을 수 있을 때 발생합니다.


**rest api 요청 -> 응답까지 프레임워크의 흐름** 
1. 프레임워크에는 http 처리가 캡슐화 되어 있어서, HTTP method에 따라 처리됩니다.  서버 개발자는 구현된 인스턴스를 사용하면 됩니다.  
2. dispatherServlet 이 request을 받습니다. 그리고 어디에서 처리할지 handlerMapping을 이용하여 요청을 처리할 Controller를 찾습니다. 
3. 2번 전에 다양한 처리가 진행됩니다. filter라든지, intercepter라든지 등등이 수행됩니다.
4. 2번 후에 controller는 데이터를 받아서 service-layer -> infralayer까지 내려가서 절차 지향적 프로그래밍을 수행합니다.
5. 그후에 controller가 다시 받고 이를 처리하는 Response 로 응답하게 됩니다. 

**분산 서비스에서의 락 처리**
1. sharding 
2. 트랜잭션을 이용한 DB락을 이용하여 처리
3. 분산 코디네이션 시스템 이용 zookeeper에 락을 요청하고  작업수행 후 락 해제 -> 분산 코디네이션이 락관리
4. 레디스의 분산락 


## PR에 관해 정리 

pr에는 2가지 방향이 존재하는것 같습니다.

1. 상급자가 결과를 확인하고 merge하는 PR
2. 하급자가 결과물을 review  요청하고  상급자는 승인 후 하급자가 merge 하는 PR
즉 merge 하는 주체에 따라 PR의 성향이 달라질 수 있다고 생각합니다.

저는 2번에 중점을 두고 PR(리뷰)를 접근 하였습니다.

### 책임의 주체가 Assignees

PR 본문에는 리뷰어가 아웃라인을 잘 이해할 수 있도록 
작업내용 , 참고자료, 주안점(고려 내용) , 연관 PR, 체크리스트를 템플릿으로 작성해두고 활용합니다.

그래서 기능 개선 / 버그 수정 / 기능 개발  모두 별도 피알로 구분하고 브랜치는 
작업 브랜치를 기준으로 따면서 진행하는 습관을 들이기

비난 및 비하는 금하며 모든 코멘트에는 명확한 요구 및 의견전달이 필요합니다.
bad : 이 부분이 좀 이해가 안되네요.
Good : 이 부분에서 nullable 한 데이터처리를 하신이유가 궁금합니다. 저희 팀 컨벤션으로는 checkNotNull 등을 이용해 미리 null 체크를 해주능게 좋을거같아요 

또한 단순한 코드의 관점만이 아니라 팀컨벤션, 언어컨벤션, 로직의 성능 등을 함께 고민하고 의견 코멘트로 달아주세요

라벨을 review-required 를 지우고 ready-to-merge 로 바꿔 달아서 pr의 상태를 표시해도 좋은 방법 같습니다.


## 알고리즘

### 비트마스킹

비트마스킹은 2진수를 통해서 비트를 하나의 켜고 , 끄고  또는 이진수끼리 덧셈 , 뺄셈을 하여 처리하는 방법론이다.

비트를 켜고, 끄고, 덧셈, 뺄셈 등을 비트연산자라고 한다.

**비트연산자의 종류**

- &(and)  , |(or), ^(Xor) , ~(반전), >>(비트 왼쪽이동), <<(비트오른쪽이동)
등이 존재한다.


비트 연산은 다음과 같은 특징을 나타낸다.

S = 10010 이라고 칭한다

비트하나만 켜기 : S |= ( 1 << idx )
비트하나만 끄기 : S &= ~( 1 << idx )
비트하나만 XOR :  S ^= ( 1 << idx )
최하위 비트 구하기 :   idx = S & (~S + 1)
해당 위치에 비트가 1인지 확인하기 :   if( S & ( 1 << idx ))
비트를 통해서 나타낼 집합의 수 구하기 :  (1 << n) - 1

**비트마스킹을 사용하는 이유** 
bool 을 선언해서 다양한 기법이 진행되는데, 이를 비트마스킹으로 처리하면 공간복잡도를 줄일 수 있습니다.

**주의할점**
비트는 INT 형일때 2^32까지 존재하고 long 일때는 대부분 2^64를 제공하니 
이것들을 모두 돌리려면 시간 복잡도가 매우 오래걸릴것입니다. 
그러므로 2^30 약 10억이 넘어가는 방법이면 다른 방법을 생각해야 한니다.




