## 마라톤

* 문제
현재 달리고 있는 선수를 앞에서 부터 표시했을 때 평소 실력이 각각 2, 8, 10, 7, 1, 9, 4, 15라고 하면 각 선수가 얻을 수 있는 최선의 등수는 (같은 순서로) 각각 1, 1, 1, 3, 5, 2, 5, 1이 된다. 예 를 들어, 4번째로 달리고 있는 평소 실력이 7인 선수는 그 앞에서 달리고 있는 선수들 중 평 소 실력이 2인 선수만 앞지르는 것이 가능하고 평소실력이 8과 10인 선수들은 앞지르는 것이 불가능하므로, 최선의 등수는 3등이 된다.

* 알고리즘 

10000명 제한이기 떄문에 N^2으로도 풀수있었다. 하지만 100만, 혹은 더큰수가 나오면 병합정렬로 풀것
기준 인덱스 왼쪽으로 더 큰수가 있으면 ch배열에 카운트를 올리는 방법으로 구현하였다. 
나중에 수가 커진다면 기준 인덱스 왼쪽으로 큰수를 찾는 방법을 생각해보자

```
#include <stdio.h>
#include <algorithm>
#include <vector>
using namespace std;

int a[10001];
int b[10001];
int main() {
    int n;
    scanf("%d", &n);
    for(int i = 1 ; i <= n; i++) { 
        scanf("%d", &a[i]);
        b[i] =1;
    }    
    for(int i = 2 ; i<= n; i++) { 
        for(int j = i-1 ; j>=1 ; j--) {
            if(a[j] >= a[i]) {
                b[i]++;
            }
        }
    }
    for(int  i = 1 ; i<= n; i++) {
        printf("%d ", b[i]);
    }
    return 0;
}
```