## 수식만들기(dfs활용)

* 문제 
길이가 N인 자연수로 이루어진 수열이 주어집니다. 수열의 각 항 사이에 끼워넣을 N-1개의 연산자가 주어집니다. 연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있습니 다.
수열의 순서는 그대로 유지한 채 각 항사이에 N-1개의 연산자를 적절히 배치하면 다양한 수 식이 나옵니다.
예를 들면
수열이 1 2 3 4 5이고 덧셈(+) 1개, 뺄셈(-) 1개, 곱셈(×) 1개, 나눗셈(÷) 1개인 일 때
만들 수 있는 수식은 많은 경우가 존재한다.
그 중 1+2*3-4/5와 같이 수식을 만들었다면 수식을 계산하는 결과는 연산자 우선순위를 따지 지 않고 맨 앞쪽 연산자부터 차례로 계산한다. 수식을 계산한 결과는 1이다.
N길이의 수열과 N-1개의 연산자가 주어지면 만들 수 있는 수식들 중에서 연산한 결과가 최대 인것과 최소인것을 출력하는 프로그램을 작성하세요.



* 알고리즘

숫자 수열이 n개 주어지면 n-1개를 끼워넣는다. 이것은 힌트이다. 첫번째가 수가 고정되어있을때 n-1번 실행된다는 소리이고 연산자를 기준으로 dfs를 작성하면된다. 

dfs의 파라미터는 재귀가 진행될 레벨과 결과값을 리턴해주는 파라미터 모델로 가야한다. 
결과값을 리턴해주지 않으면 각 op마다 결과값을 넣는 변수를 설정해야하며 
마지막에 비교할때 4가지의 max를 그리고 4가지의 min을 비교해야하기때문이다.

```
#include <stdio.h>
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

int n,maxi = -2147000000, mini = 2147000000;

int a[20], op[5];

void DFS(int L,int res){
    if(L == n){
        if(res > maxi) maxi = res;
        if(res < mini) mini = res;
    } else {
       if(op[0]>0){
           op[0]--;
           DFS(L+1, res+a[L]);
           op[0]++;
       }
       if(op[1]>0){
           op[1]--;
           DFS(L+1, res-a[L]);
           op[1]++;
       } 
       if(op[2]>0){
           op[2]--;
           DFS(L+1, res*a[L]);
           op[2]++;
       } 
       if(op[3]>0){
           op[3]--;
           DFS(L+1, res/a[L]);
           op[3]++;
       }  
    }
}

int main(){

    scanf("%d", &n);

    for(int i = 0; i<n; i++){
        scanf("%d",&a[i]);
    }
    for(int  i = 0; i<4; i++){
        scanf("%d",&op[i]);
    }
    DFS(1,a[0]);
    printf("%d\n%d",maxi,mini);
    return 0;
}
```