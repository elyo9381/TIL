## 네트워크

>[! info] 토폴로지가 왜 중요한지 ?
> 네트워크 토폴로지는 노드와 링크가 어떻게 배치되어 잇는지에 대한 방식이자 연결 행태를 의미
> ==네트워크 토폴로지를 통해 병목된 구간을 짐작할수 있고, 토폴리지 수정을 통해 병목을 해결할 수 있다.==
> - 트리 토폴로지 
> 	- 노트의 추가 , 삭제가 쉬우며 특정 노드에 트래피이 집중될 때 하위 노드에 영향을 끼침
> - 버스 토폴로지 
> 	- 버스 토폴로지는 스푸핑이 가능한 문제점 존재 
> - 스타 토폴로지
> - 링형 토폴로지
> - 메시 토폴로지


>[! info] http / X  마다의 특징 ?
>- http/1.0
>	- 한 연결당 하나의 요청을 처리하도록 설계됨
>	- RTT : 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간
>	  RTT를 줄위기 한 노력이 존재 : 이미지 스플리팅, 코드 압축, base64인코딩
>- http/1.1
>	- keep-alive라는 옵션으로 여러개의 파일을 송수신할 수 있게 바뀌었습니다.
>		- 짧은시간마다 연결하는  handshake 비용을 절감
>- http/2
>	- 멀티 플렉싱, 헤더 압축, 서버푸시 요청의 우선순위 처리 
>		- 멀티플렉싱 : 여러 스트림을 사용하여 송수신하는 기능 (스트림 내의 데이터들도 쪼개져있음)
>		- 헤더압축 : 허프만 알고리즘을 사용하여 헤더 압축
>		- 서버푸시 : 서버가 클라의 요청없이 리소스를 푸시할 수 있는 기능( 최초 요청 필요 )
>	- HTTPS 
>		- SSL/TLS를 통해 신뢰할 수 있는 HTTP 요청
>			- SSL/TLS: 애플리케이션과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP
>			- 보안세션을 기반으로 클라와 서버가 키를 공유하고 이를 기반으로 인증절차를 거쳐 1RTT 이후에 데이터 송수신
>			- 사이퍼 슈트구성 :키교환 , 인증, 해싱 , 블록암호 운용방식
>		- SSL/TLS 동작 순서
>			1. 클라 -> 서버 사이퍼 슈트 전달
>			2. 서버 사이퍼 슈트에 적힌 알고리즘을 통해서 인증 메커니즘 시작 
>				1. CA 에서 발급한 인증서를 가지고 신뢰가능한 서버임을 보장
>				2. 자신의 사이트와 공개키를 CA에 전달-> 인증서 발급 
>			3. 서버 클라 인증서 전달 ( 암호화됨 )
>- http3
>	- UDP, QUIC 기반  통신 프로토콜 


>[!info] SSL/TLS
> 애플리케이션 계층과 전송계층 사이의 보안을 계층입니다.
> TCP통신상에서 3wayhandshake 를 진행할때, 사이퍼슈트를 기반으로 통신하여 , 상호 간의 보안을 높여 통신하는 방법입니다. 
> 사이퍼슈트 : 키교환 알고리즘, 인증 알고리즘, 블록암호 운용방식들을 명시한 텍스트리스트입니다.
> 사이퍼슈트를 통해 암호화된 통신이 진행되고, 이때 CA가 존재하는데, 인증서의 명시된 공캐기로 서버나 클라가 신뢰성있는 사이트임을 확인하고 통신가능합니다.


>[!info] 블록암호 운용방식
> 암호문 전체를 암호화 하는것이 아닌 작은 단위(블록)로 쪼개고 이를 해싱하는 방법입니다.

> [! info] 허프만 알고리즘

> [! info] 디피헬만

> [! info] osi7 계층 ,  TCP/IP 4계층 의 차이  ?
> 
> OSI 7계층은  네트워크 계층을 7개로 분할한 것이고 
> TCP/IP 4계층 네트워크를 계층을 4개로 분할한것입니다. 
> 4계층은 애플리케이션, 전송, 인터넷, 링크로 구성되며
> 4계층의 애플리케이션은 7계층의 애플리케이션, 프레젠테이션, 세션 계층을 하나로 봅니다. 
> 또한 4계층의 링크 계층은 7계층의 데이터링크, 물리계층을 하나로 봅니다. 


>[! info] 전송 계층에 대한 말해보세요
>	- 데이터 전송방법에 대한 계층 입니다.
>	- 주로 TCP, UDP를 사용합니다.
>	- TCP 는 가상회선 방식으로 순서를 보장하고 수신여부를 확인합니다.
>	- UDP는 데이터 그램 패킷 교환 방식으로 순서 보장 및 수신여부를 확인하지 않습니다.
 

> [! info] 3 WAY HANDSHAKE 를 설명하세요
>  -  왜 이런 과정이 존재하는거죠 ? 
> 		- 서버 , 클라이언트가 준비가 되어있는지 확인하는 절차가 필요하기 때문
> 		- 신뢰절차를 구축하기 위해서 
> - 연결해제시 과정을 설명해보세요 
> 		1. 클라가 서버에 fin 요청 
> 		2. 서버 클라아게 ack 응답
> 		3. 서버 클라에서 fin 요청
> 		4. 클라 time wait 상태에서 일정시간 act 서버에게 응답 
> 	- 왜 4번에서 클라는 time wait를 가지나요 ? 
> 		- 지연 패킷이 발생할 경우를 대비하기 위함
> 		- 바로 닫게 되면 클라, 서버가 완전히 닫힌 상태를 모르기 때문에, 재연결시 접속 오류가 날수있음


>[!info] stateless, stateful
>- stateful : 여러 요청사이에 공유되는 상태가 존재하며 이를 보존하는것 입니다.  
>	- 서버가 여러대라면 이를 동기화 하기 위한 DB 저장이라든기 뭔가가 필요합니다.
>- stateless : 여러 요청사이에 공유되는 상태가 존재하지 않는것입니다.
>	- 클라와 서버간에 특정 정보만 주고 받는행위를 말할수 있습니다.