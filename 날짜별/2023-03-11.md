
# 면접 공부 

## 캐시메모리의 특징을 말해주세요 

빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말한다.

### 캐시 등록 및 처리 방법
1. 등록 방법 
- 캐시는 하드웨어로 구성된 해시테이블이라고 볼수있다. 
- 캐시는 블록으로 구성되어있으며 특정 사이즈가 미리 정해져있다 ( 하드웨어 적으로 )
- 이를 통해서 비트 연산을 통해 해시 테이블을 구현한다. 
2. 캐시가 등록되고 적중되면 캐시 히트 , 캐시 미스라고 말한다. 
3. 캐시가 등록 될때 여러가지 방법이 존재한다. 
	1. 직접 매핑
		- 캐시는 블록이라고 했고 비트를 사용한다고 했다. 
		- 메모리의 주소값을 통해서 캐시 블록과 매핑된다. 
		- 메모리의 크기가 캐시의 N배 라면 N배 만큼 캐시가 충돌이 찾을수있다. 
		- 왜냐하면 특정 블록에 해당 메모리의 큰 범위가 들어가기 때문이다. 
	1. 연관 매핑
		- 캐시블록의 키로 메모리를 모두 탐색후 비어있으면 올리는 것이다. 
		- 그렇기 때문에 속도가 느리다.
	2. 집합 연관 매핑
		 - 집합 연관 매핑은 직접 매핑과 연관 매핑을 적절히 사용하는 매핑이다. 
		 - 메모리의 주소값을 통해서 캐시 블록과 매핑된다. 주소값에 비트별 연산을 통해 해당 범위를 줄였다. 
4. 메모리에서 캐시에 등록 할때 지역성을 고려해서 캐시를 등록한다. 
	- 공간 지역성
	- 시간 지역성


[캐시 메모리에 대한 참고 ](https://parksb.github.io/article/29.html)


##  클래스의 차이 ( 아웃터 , 이너 , 스태틱 ) 
- 아웃터 클래스 는 일반적으로 사용하는 가장 밖의 범위에 존재하는 클래스입니다. 
- 클래스의 내부 클래스를 정의하는것이 이너 클래스 입니다. 
- 스태틱 클래스는 static 키워드를 붙여 공유 클래스로 만드는것이고 , 이것은 아우터 클래스와 거의 동일하다고 볼수있습니다. 
	- 이때 스태틱 클래스는 아웃터 클래스의 변수도 접근이 가능합니다. 

아웃터 클래스 없이는 이너 클래스를 접근할 수 없습니다.


## 프로세스와 쓰레드
- 백엔드적 지식을 빗대어 설명하면 좋을것 같다.

## 추상 클래스와 인터페이스 
추상클래스
- 추상클래스는 추상 메소드를 정의 할수 있는 클래스입니다. 
- 추상 메소드는 다른 클래스에서 직접 정의해서 사용할 수 잇습니다. 
- 추상 메소드는 일반 메소드를 정의해서 추상 클래스를 상속 받는 자식 클래스가 부모 클래스의 일반 메소드를 공통적으로 사용 할 수 있습니다. 
  -> 그렇기에 공통적인 부분을 추상클래스로 올려 재사용을 할 수 있습니다. 

인터페이스 
- 인터페이스는 추상 메소드를 정의 할 수 있습니다. 
- 추상클래스와 다른점은 이건 정의부만 작성하므로 다른 클래스들의 중복된 인터페이스 상속이 가능합니다. 
- 추상클래스 처럼 일반 메소드를 만들지 못하여 일반 메소드의 중복을 처리 할수는 없습니다. 






# 알고리즘


### 조합을 구하는 방법 

1. 조합을 구하는데 3개 이하이다 .
``` c++
  int n = 10;
   int array[] = {1,2,3,4,5,6,7,8,9,10};
   int check[10] = {0,};
	for( int i = 0 ; i < n ; i++){
		for( int j = 0 ; j < i ; j++){
			for( int k = 0 ; k < j ; k++){
				check[i] = 1;
				check[j] = 1;
				check[k] = 1;
				solve();
				check[i] = 0;
				check[j] = 0;
				check[k] = 0;
			}
		}
	}
```
2. 조합을 구하는데 3개 초과이다. 
   ~~~ c++
   
   int n = 5, k = 3, a[5] = {1,2,3,4,5};
   void combi( int start, vector<int> b){
	   if(b.size() == k) {
		   print(b);
		   return;
	   }
		for(int i = start + 1; i <n ; i++){
			b.push_back(i);
			combi( start, b);
			b.pop_back();
		}
		return ;
   }
	int main(){
		vector<int> b;
		combi(-1,b);
		return 0;
	}
   ~~~

### 문제 접근에 대한 고찰 
1. 최대 , 최소 를 보고 가늠해라 
2. 1을 모르겠으면 브루트포스 가라 
3. 2번 성공 및 실패후  최적화를 시켜라  ( dp , 그리디 , 솔브한 빅오 보다 빠르게 )


